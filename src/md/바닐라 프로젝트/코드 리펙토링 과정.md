<div style = "padding: 30px">
  # 바닐라 프로젝트 코드 리펙토링 기록
  
  ## 1. 마크업 리팩토링
  
  접근성과 시맨틱한 마크업을 하기 위해서 리펙토링을 진행하였다.
  
  - 영화 포스터 이미지 접근성
  - 탭 버튼 접근성
  - 중복되는 컴포넌트 data attribute 부여하여 분리된 마크업 구조
  
  ### 1) 접근성을 고려한 마크업 리펙토링
  
  #### 1-1) 영화 포스터 이미지 수정
  
  alt 속성에 해당 영화 이름이 반영되게 수정하였고, 또한 이미지가 로딩되기전에 나오는 로딩 ui에 role="status" + aria-live 속성을 추가해주었다.
  
  ```
  (수정 전)
  
  <div class="img-container"><img src="https://i.ibb.co/TBKYb860/b-Akhvi-Eo-Hhtc-H5-tmoh-Ry-DDt-MEn36-2-Cf-wk-fqi-NILm-P1o1140e-H0-NUO2wret0et-EEDl8yrzcg4x6-HHLgk-Q.webp" class="movie-img" alt="영화 포스터"></div>
   <span class="loader"></span>
  
  ```
  
  ```
  (수정 후)
  
  <div class="img-container">
  <img src="https://i.ibb.co/TBKYb860/b-Akhvi-Eo-Hhtc-H5-tmoh-Ry-DDt-MEn36-2-Cf-wk-fqi-NILm-P1o1140e-H0-NUO2wret0et-EEDl8yrzcg4x6-HHLgk-Q.webp" class="movie-img" alt="휴민트"></div>
   <span class="loader" role="status" aria-label="로딩중"></span>
  
  
  ```
  
  #### 1-2) 탭 버튼 및 탭 패널
  
  - 기본 활성화 될 탭 버튼 지정
    (aria-selected = "true") 부여
  - 각 tabpanel에 aria-labelledby로 연결되는 탭 id 부여하기
  
  ```
  코드가 다소 길어,  수정 후 코드만  문서에 추가하였다.
  (수정 후)
            <div class="point-tab" role="tablist">
              <ul role="none">
                <li role="none">
                  <button
                    class="lion-point-button"
                    id="tab-1"
                    type="button"
                    role="tab"
                    aria-controls="panel-1"
                    aria-selected="true"
                  >
                    Lion-POINT 조회
                  </button>
                </li>
                <li role="none">
                  <button
                    class="lion-point-button"
                    id="tab-2"
                    type="button"
                    role="tab"
                    aria-controls="panel-2"
                    aria-selected="false"
                    aria-label="lion-POINT 카드 번호로 적립"
                  >
                    Lion-POINT 카드 번호
                  </button>
                </li>
              </ul>
             <div class="point-tabpanel" role="tabpanel" id="panel-1" aria-labelledby="tab-1">
                  <form class="lion-point-panel" method="post">
                    //탭 패널 1 해당 내용 ...
                  </form>
            </div>
  
            <div class="point-tabpanel" role="tabpanel" id="panel-2" aria-labelledby="tab-2">
                  <form class="card-number-point-panel" method="post">
                    //탭 패널 2 해당 내용 ...
                  </form>
                </div>
            </div>
  ```
  ### 2) 코드 품질을 고려한 마크업 리펙토링
 -  탭 패널 1과 2에 중복되는 data-value="maximum-point" 버튼이 2개 있음 
 → 자바스크립트에서 제어하기 용이하게  data attribute 추가
 ```
 (수정 후)
 패널 1)
 <button
   type="button"
   data-value="maximum-point"
   data-action="apply-max-point"
   data-target="panel-1" > 최대 적용</button>

패널 2)
<button
  type="button"
  data-value="maximum-point"
  data-action="apply-max-point"
  data-target="panel-2" >최대 적용</button>

```
## 2. 할인 영역의  탭에  UrlSearchParams 사용
해당 탭을 클릭 시, 해당 탭 패널로 전환이 될 때  tab과 tabapanel의 id가 들어간 Url를 UrlSearchParams 사용한  함수를 추가하였다.
탭 클릭 시 발생하는 handelTabClick 함수 안에 url이 저장된 함수를  넣어주기  위해서 url를 저장하는 함수를  먼저 만들어 주었다.
URL과 URLSearchParams 함께 사용하여, 기존의  URL를 조작하는 방식으로 함수를 만들었다.

```

// url searchParams 사용하여, 해당 탭 패널 id 저장 함수
function setActiveTabUrl(tab, panelValue) {
const url = new URL(location.href);
url.searchParams.set('tab', tab.id);
url.searchParams.set('panel', panelValue);
history.pushState({}, '', url.toString()); // 해당 URL를 주소창에 업데이트 해주기
}

```

이렇게 한 후, 새로고침 시에 기존에 활성화가 되어있던 탭패널이 화면에 보여야 하기 때문에,  새로고침을 해당 페이지가 보이는 함수를 다시 만들어 줘야 했다.

새로 고침 시  해당 url의 활성화 된 Ui가 브라우저에 보여져야 하므로, 새로고침 url에 해당되는 타켓을 찾아서 활성화시켜주는 구조로 함수 구조를 구성했다.

```

// 새로고침 시, 현재 페이지의 url의 활성화 탭을 그대로 읽어오는 함수
function resetTabUrl() {
const resetUrl = new URL(location.href);
const tabId = resetUrl.searchParams.get('tab');

// 안전한 프로그래밍 해당 타켓이 아닐 시 즉시 함수 종료
if (!tabId) return;

// 해당 url의 해당 탭과 탭패널 찾은 후에 활성화 속성 부여
const target = document.getElementById(tabId);
const targetValue = getAttr(target, 'aria-controls');
const activeTargetPanel = document.getElementById(targetValue);
activeTab(target, activeTargetPanel);
}
resetTabUrl();

```
## 3. 자바스크립트 리팩토링

### 1) 접근성을 고려한 탭 및 탭패널 리펙토링

리펙토링이 필요한 부분들은 다음과 같다.

- 탭 버튼/패널 상태 변경 시 해당 탭 패널의 hidden + aria-labelledby 까지 함께 제어하기
 - 활성 탭: `aria-selected="true" tabindex="0"`
 - 비활성 탭: `aria-selected="false" tabindex="-1"`
 - 활성 패널: `hidden=false` / 비활성 패널: `hidden=true`
- `handleTabClick`에서 “hidden 처리”

이렇게 기능을 구현한 handleTabClick 함수는 다음과 같다.

```

function handleTabClick(e) {
if (!e.target.closest('.lion-point-button')) return;
removeAllActive(POINT_TABS, 'active'); // 모든 버튼 활성화 초기화
removeAllActive(LION_POINT_BUTTON, 'active');
setAllAttr(LION_POINT_BUTTON, 'aria-selected', 'false'); // 모든 버튼 접근성 속성 초기화
const target = e.target.closest('button'); // 부모요소에서 가장 가까운 버튼 찾기
const targetValue = getAttr(target, 'aria-controls'); // 해당 속성값 읽기
const activeTarget = document.getElementById(targetValue);
isActive(target);
isActive(activeTarget); // 해당되는 타켓에 active 클래스명 추가
attr(target, 'aria-selected', 'true');
attr(activeTarget, 'tabindex', '0'); // 해당되는 타켓에 상태 전환
attr(activeTarget, 'hidden', null); // 해당되는 타켓에 hidden 속성 삭제

// 비활성 패널 hidden 처리
POINT_TABS.forEach((panel) => {
if (panel !== activeTarget) {
attr(panel, 'hidden', '');
attr(panel, 'tabindex', '-1');
}
});
}

```

이렇게 하나의 함수에 활성화/ 비활성화 탭에 대한 제어를 동시에 하니 코드가 길어지고, 가독성이 떨어져 다시 탭 속성 초기화와 활성화 탭에 대한 함수를 나누고 최종적으로 handleTabClick 함수에 넣어주는 식의 구조를 설계했다.

```

(수정 후)
// url searchParams 사용하여, 해당 탭 패널 id 저장 함수
function setActiveTabUrl(panel) {
const url = new URL(location.href);
const panelValue = getAttr(panel, 'aria-controls');

url.searchParams.set('tab', panelValue);
history.pushState({}, '', url.toString());
}

// 새로고침 시, 현재 페이지의 url의 활성화 탭을 그대로 읽어오는 함수
function resetTabUrl() {
const resetUrl = new URL(location.href);
const panelId = resetUrl.searchParams.get('tab'); //해당 panel 찾기
const target = document.getElementById(panelId);
if (!panelId) return;
const targetValue = getAttr(target, 'aria-labelledby'); //해당 tab 찾기
const activeTargetPanel = document.getElementById(targetValue);
activeTab(target, activeTargetPanel);
}
resetTabUrl();
function handleTabClick(e) {
if (!e.target.closest('.lion-point-button')) return;
const target = e.target.closest('button'); // 부모요소에서 가장 가까운 버튼 찾기
const targetValue = getAttr(target, 'aria-controls'); // 해당 속성값 읽기
const activeTargetPanel = document.getElementById(targetValue);
resetTabsState(POINT_TABS, LION_POINT_BUTTON);
activeTab(target, activeTargetPanel);
}

```


### 2) 가드/라우팅 · 초기 진입 안정화를 위한 리펙토링
이하 목록들 위주로 초기 페이지 진입 시 가드 함수를 리펙토링하였다.
- redirectPage()에서 state를 외부 destructuring이 아니라 함수 인자로 받아 순수 함수 형태로 만들기
- 가드 조건을 “필수 state 키 목록”으로 표준화하기
- redirect 시 return으로 함수 흐름 종료 확실히 하기

```

(수정 전)
const { price, movieId, timetableId, seats } = state;

redirectPage();
function redirectPage() {
if (movieId === null) {
location.href = '/src/page/main/index.html';
} else if (timetableId === null) {
location.href = '/src/page/booking/index.html';
} else if (!seats || seats.length === 0) {
location.href = '/src/page/seat/index.html';
} else return;
}

```

```

(수정 후)
// 함수 실행
redirectPage(state);

// state를 함수 인자로 받기
function redirectPage(state) {

// state의 필수 조건 목록 상수 선언
const required = ['movieId', 'timetableId', 'seats', 'price'];
if (state[required[0]] === null) {
return (location.href = '/src/page/main/index.html');
}
if (state[required[1]] === null) {
return (location.href = '/src/page/booking/index.html');
}
if (!state[required[2]] || state[required[2]].length === 0) {
return (location.href = '/src/page/seat/index.html');
}
return;
}

```

### 3) 이벤트 설계 · 역할 맞는 이벤트에 연결
버블링 오작동 또는  다소 어색한 UX 측면을  고려하여, 이벤트가 발생하는 요소에 적절한 이벤트를 연결해주는 설계 리펙토링 과정을 거쳤다.

### 3-1)  중복된 함수 하나로 합치기
#### 1)  포인트 검증 함수 리펙토링
패널 1과 패널 2에 동일하게 존재하는 요소의 적용되는 함수를 하나로 통일하기 위해서  마크업에 해당 요소에 공통으로 들어가는 데이터 속성(data-point)을  추가해주었다.
중복된 함수를 하나로 합친 후에 해당 input요소가 아닌 각 패널의 form 요소에 포인트 검증을 하는 함수를 연결해주었다.

```

<마크업 수정 후>
<input
type="text"
id="use-current-point"
data-point
placeholder="포인트 입력(100p 단위로 사용가능)"
aria-describedby="panel-2-point-description"
                      />

(수정 전)
// 패널 1
function pointInputAuth(e) {
e.preventDefault();
if (!e.target) return;
const target = document.querySelector('[data-target]');
let value = parseInt(target.value, 10);
// 조건문 만들기
// 거짓: 숫자가 아니면 알림창 뜨기
// 참: 해당 값 표시
if (isNaN(value) || value % 100 !== 0 || value === 0) {
alert('100 단위로 포인트를 입력하세요');
return false;
}

return value;
}
// 패널 2
function currentInputAuth() {
const target = document.getElementById('use-current-point');
if (!target) return;
let value = parseInt(target.value, 10);
// 조건문 만들기
// 거짓: 숫자가 아니면 알림창 뜨기
// 참: 해당 값 표시
if (isNaN(value) || value % 100 !== 0 || value === 0) {
alert('포인트를 100 단위로 입력하세요');
return false;
}
return value;
}

```

```

(수정 후)

// 패널 1/ 패널 2
function pointInputAuth(e) {
e.preventDefault();
if (!e.target) return;
const form = e.target.closest('form');
const target = form.querySelector('[data-point]');
console.log(target);

let value = parseInt(target.value, 10);
// 조건문 만들기
// 거짓: 숫자가 아니면 알림창 뜨기
// 참: 해당 값 표시
if (isNaN(value) || value % 100 !== 0 || value === 0) {
alert('100 단위로 포인트를 입력하세요');
return false;
}

return value;
}

// 폼 서식 최대 적용 버튼 눌렀을 때 포인트 적용 인증 이벤트
LION_POINT_PANEL_FORM.addEventListener('submit', pointInputAuth);
CARD_NUMBER_POINT_PANEL_FORM.addEventListener('submit', pointInputAuth);

```

#### 2) 비밀번호 검증 함수 리펙토링
비밀번호 검증 함수 또한 패널별로 분리를 하였는데, 함수의 로직이 동일하므로, 하나로 통일을 하는 리펙토링 과정을 거쳤다.
```

(수정 전)
// 패널 1
function lionPointCardPasswordAuth() {
const target = document.querySelector('#card-point-password');
if (!target) return;
if (target.value.length < 6 || target.value.length > 8) {
alert('비밀번호를 6~8자리로 입력하세요');
return false;
} else {
return target.value;
}
}

//패널 2
function lionPointCardNumberPasswordAuth() {
const target = document.getElementById('card-number-password');
if (!target) return false;
if (target.value.length < 6 || target.value.length > 8) {
alert('비밀번호를 6~8자리로 입력하세요');
return false;
} else {
return target.value;
}
}

```


```

(수정 후)
// 패널 1/패널 2 공통 함수
function cardPasswordAuth(e) {
const form = e.target.closest('form');
const target = form.querySelector('input[type="password"]');
if (!target) return;
if (target.value.length < 6 || target.value.length > 8) {
alert('비밀번호를 6~8자리로 입력하세요');
return false;
} else {
return target.value;
}
}

```


### 3-2) 이벤트 설계에 맞는  이벤트 연결
#### 1) 최대 적용 이벤트를   공통 부모에 위임
-  “최대 적용”은 `POINT_TAB` 전체 click에 붙어있음 → 버블링 비용/오작동 위험
-  `.tabpanel-container` 또는 공통 부모에 위임하되 `data-action`으로 명확히 분기하기
```

(수정 후)
function maximumPoint(e) {
const target = e.target.closest('[data-target]');

if (!target) return;
const input = target.parentElement.querySelector('input');
e.preventDefault();
if (input.value === '' || input.value % 100 !== 0 || input.value === '0') {
return alert('포인트 최대 적용 실패 ❌');
}
if (!discountPriceAuth(e)) return;

// 위의 할인 가격 검증까지 다 통과된 후에 포인트 최대 적용 완료
alert('포인트 최대 적용 완료 ✅');

// 할인 가격 푸터에 즉시 표시
discountPrice(input.value);
// 총 가격 푸터에 즉시 표시
totalPriceCal();
}

// 공통 부모요소에 이벤트 연결
TAB_PANEL_CONTAINER.addEventListener('click', maximumPoint);

```
</div>


```
